01 // Gabriel Aszalos 协助完成了这个示例
02 // runner 包管理处理任务的运行和生命周期
 03 package runner
04
05 import (
06 "errors"
07 "os"
08 "os/signal"
09 "time"
10 )
11
12 // Runner 在给定的超时时间内执行一组任务，
13 // 并且在操作系统发送中断信号时结束这些任务
14 type Runner struct {
15 // interrupt 通道报告从操作系统
16 // 发送的信号
17 interrupt chan os.Signal
18
19 // complete 通道报告处理任务已经完成
20 complete chan error
21
22 // timeout 报告处理任务已经超时
23 timeout <-chan time.Time
24
25 // tasks 持有一组以索引顺序依次执行的
26 // 函数
27 tasks []func(int)
28 }
29
30 // ErrTimeout 会在任务执行超时时返回
31 var ErrTimeout = errors.New("received timeout")
32
33 // ErrInterrupt 会在接收到操作系统的事件时返回
34 var ErrInterrupt = errors.New("received interrupt")
35
36 // New 返回一个新的准备使用的 Runner
37 func New(d time.Duration) *Runner {
38 return &Runner{
39 interrupt: make(chan os.Signal, 1),
40 complete: make(chan error),
41 timeout: time.After(d),
42 }
43 }
44
45 // Add 将一个任务附加到 Runner 上。这个任务是一个
46 // 接收一个 int 类型的 ID 作为参数的函数
47 func (r *Runner) Add(tasks ...func(int)) {
48 r.tasks = append(r.tasks, tasks...)
49 }
50
51 // Start 执行所有任务，并监视通道事件
52 func (r *Runner) Start() error {
53 // 我们希望接收所有中断信号
54 signal.Notify(r.interrupt, os.Interrupt)
55
56 // 用不同的 goroutine 执行不同的任务
57 go func() {
58 r.complete <- r.run()
59 }()
60
61 select {
62 // 当任务处理完成时发出的信号
63 case err := <-r.complete:
64 return err
65
66 // 当任务处理程序运行超时时发出的信号
67 case <-r.timeout:
68 return ErrTimeout
69 }
70 }
71
72 // run 执行每一个已注册的任务
73 func (r *Runner) run() error {
74 for id, task := range r.tasks {
75 // 检测操作系统的中断信号
76 if r.gotInterrupt() {
77 return ErrInterrupt
78 }
79
80 // 执行已注册的任务
81 task(id)
82 }
83
 84 return nil
85 }
86
87 // gotInterrupt 验证是否接收到了中断信号
88 func (r *Runner) gotInterrupt() bool {
89 select {
90 // 当中断事件被触发时发出的信号
91 case <-r.interrupt:
92 // 停止接收后续的任何信号
93 signal.Stop(r.interrupt)
95 return true
96
97 // 继续正常运行
98 default:
99 return false
100 }
101 } 